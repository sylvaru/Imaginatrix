// frustum_culling.comp
#version 450
layout(local_size_x = 64) in;


layout(push_constant) uniform PushConstants 
{
    mat4 viewProj;
    uint maxInstances;
    uint debugCulling;
} pcs;

struct InstanceData 
{
    mat4 modelMatrix;
    uint textureIndex;
    float boundingRadius;
    uint batchID;       
    uint _padding;
};

struct GPUIndirectCommand 
{
    uint indexCount;
    uint instanceCount;
    uint firstIndex;
    int  vertexOffset;
    uint firstInstance;
    uint _padding[11]; 
};

layout(std430, set = 2, binding = 0) readonly buffer InputBuffer 
{
    InstanceData instances[];
} inputData;


layout(std430, set = 2, binding = 1) buffer OutputBuffer 
{
    GPUIndirectCommand commands[]; 
} culledData;

layout(std430, set = 2, binding = 1) buffer InstanceOutputBuffer 
{
    layout(offset = 1024) InstanceData instances[]; 
} culledInstances;


bool isVisible(vec3 worldPos, float radius) 
{
    vec4 clipPos = pcs.viewProj * vec4(worldPos, 1.0);

    // Dynamic Debug Scale
    float debugScale = (pcs.debugCulling == 1) ? 0.5 : 1.0;
    
    // Calculate the acceptance limit in clip space.
    // Adding radius ensures that if any part of the sphere touches the frustum, it stays.
    float limit = (clipPos.w * debugScale) + radius;

    // Check against X and Y (Left, Right, Top, Bottom)
    // Using abs() handles both sides of the axis in one check.
    if (abs(clipPos.x) > limit || abs(clipPos.y) > limit) return false;

    // Check against Z (Near and Far)
    // Check if the sphere is completely behind the near plane or past the far plane.
    if (clipPos.z < -radius || clipPos.z > clipPos.w + radius) return false;

    return true;
}

void main() {
    uint gIdx = gl_GlobalInvocationID.x;
    if (gIdx >= pcs.maxInstances) return;

    // Only fetch what we need for the test
    // Read only the 4th column (index 3) of the matrix and the radius.
    // This avoids pulling the other 3 columns into GPU registers unnecessarily.
    vec3 worldPos = inputData.instances[gIdx].modelMatrix[3].xyz;
    float radius  = inputData.instances[gIdx].boundingRadius;

    if (isVisible(worldPos, radius)) 
    {
        // Now that we know it's visible, fetch the metadata
        uint bID = inputData.instances[gIdx].batchID;
        
        // Atomic increment to find our slot in the specific batch
        uint localIdx = atomicAdd(culledData.commands[bID].instanceCount, 1);
        
        // Calculate global destination index based on the batch's starting offset
        uint globalDestIdx = culledData.commands[bID].firstInstance + localIdx;
        
        // Heavy load happens only for visible objects
        culledInstances.instances[globalDestIdx] = inputData.instances[gIdx];
    }
}


