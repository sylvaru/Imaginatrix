// frustum_culling.comp
#version 450
layout(local_size_x = 64) in;

layout(push_constant) uniform PushConstants 
{
    mat4 viewProj;
    uint maxInstances;
    uint debugCulling;
    uint batchOffsets[16]; 
} pcs;

struct InstanceData 
{
    mat4 modelMatrix;
    uint textureIndex;
    float boundingRadius;
    uint batchID;       
    uint _padding;
};

struct GPUIndirectCommand 
{
    uint indexCount;
    uint instanceCount;
    uint firstIndex;
    int  vertexOffset;
    uint firstInstance;
    uint _padding[11]; 
};

layout(std430, set = 2, binding = 0) readonly buffer InputBuffer 
{
    InstanceData instances[];
} inputData;

layout(std430, set = 2, binding = 1) buffer OutputBuffer 
{
    GPUIndirectCommand commands[]; 
} culledData;

layout(std430, set = 2, binding = 2) buffer InstanceOutputBuffer 
{
    InstanceData instances[]; 
} culledInstances;


bool isVisible(vec3 worldPos, float radius) 
{
    vec4 clipPos = pcs.viewProj * vec4(worldPos, 1.0);
    float debugScale = (pcs.debugCulling == 1) ? 0.5 : 1.0; // Dynamic Debug Scale

    // Calculate the acceptance limit in clip space.
    // Adding radius ensures that if any part of the sphere touches the frustum, it stays.
    float limit = (clipPos.w * debugScale) + radius;

    // Check against X and Y (Left, Right, Top, Bottom)
    // Using abs() handles both sides of the axis in one check.
    if (abs(clipPos.x) > limit || abs(clipPos.y) > limit) return false;

    // Check against Z (Near and Far)
    // Check if the sphere is completely behind the near plane or past the far plane.
    if (clipPos.z < -radius || clipPos.z > clipPos.w + radius) return false;

    return true;
}

void main() 
{
    uint gIdx = gl_GlobalInvocationID.x;
    if (gIdx >= pcs.maxInstances) return;

    InstanceData instance = inputData.instances[gIdx];
    vec3 worldPos = instance.modelMatrix[3].xyz;
    float radius  = instance.boundingRadius;

    if (isVisible(worldPos, radius)) 
    {
        uint bID = instance.batchID;
        
        // Atomic increment for the draw command (instanceCount)
        uint localIdx = atomicAdd(culledData.commands[bID].instanceCount, 1);
        
        // Tell the indirect command to start reading at the correct offset
        culledData.commands[bID].firstInstance = pcs.batchOffsets[bID];
        // Calculate global destination index based on the batch's starting offset
        uint globalDestIdx = pcs.batchOffsets[bID] + localIdx;
        
        culledInstances.instances[globalDestIdx] = instance;
    }
}